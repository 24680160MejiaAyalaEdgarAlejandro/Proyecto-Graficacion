<div>
 <h2> üìò Unidad 1: Fundamentos de la Graficaci√≥n por Computadora üñ•Ô∏è </h2>
   </div>
   <div>
<h2> üìàüìâ Graficaci√≥n | SCC-1010 | Ingenier√≠a en Sistemas</h2>
   </div>
   
### üõ†Ô∏è Tecnolog√≠as y Entorno
![Git Bash](https://img.shields.io/badge/Git%20Bash-F05032?style=for-the-badge&logo=git&logoColor=white) 
![Blender](https://img.shields.io/badge/Blender-%23F5792A.svg?style=for-the-badge&logo=blender&logoColor=white)
![Windows](https://img.shields.io/badge/Windows-0078D4?style=for-the-badge&logo=windows&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54) 

Lenguaje: Python üë©‚Äçüíªüêç                     
Software Core: Blender 5.0 (Motor de renderizado y modelado procedural)               
Sistema Operativo: Windows 11 ü™ü                  
Control de Versiones: Git & GitHub             

---

> [!IMPORTANT]
> **DISE√ëO REACTIVO:** Bienvenido al repositorio oficial de la Unidad 1. Este espacio documenta la transici√≥n de sistemas puramente textuales a entornos visuales de alta complejidad, utilizando la API de 
Blender 5.0 y Python para dominar la bidimensionalidad y el realismo 3D.


![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)



<div align="center">
  
  <h3> 
    „Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è 1.1 Historia y Evoluci√≥n de la Graficaci√≥n„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è
  </h3>

</div>

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<div>  <h3> 1.1  </h3></div> La graficaci√≥n por computadora no naci√≥ como un fin art√≠stico, sino como una necesidad de visualizaci√≥n de datos complejos. Su evoluci√≥n se puede dividir
en hitos que marcaron la transici√≥n de sistemas puramente textuales a los entornos visuales inmersivos de hoy en d√≠a.

<div>  <h3>üìú Cronolog√≠a del Salto Tecnol√≥gico</h3></div>

‚óæLa Era de los Pioneros (1950 - 1960): * Whirlwind (1951): La primera computadora capaz de mostrar gr√°ficos en tiempo real en un osciloscopio.
              

‚óæSketchpad (1963): Ivan Sutherland revoluciona la industria al crear el primer programa de dibujo asistido por computadora (CAD). Introdujo conceptos de interacci√≥n humana mediante el 
 "l√°piz √≥ptico" y estructuras de datos jer√°rquicas.

‚óæLa Revoluci√≥n del Algoritmo (1970 - 1980): * Aparici√≥n de los primeros algoritmos de sombreado (Shading). Se desarrollan m√©todos para que los objetos dejen de parecer "alambre" y 
 tengan superficies s√≥lidas.
                
‚óæFundaci√≥n de empresas ic√≥nicas como Pixar y el surgimiento de los primeros largometrajes con CGI.

‚óæLa Era del Realismo y GPUs (1990 - Presente): * Salto evolutivo hacia la manipulaci√≥n de objetos en tres dimensiones con una profundidad visual sin precedentes.

‚óæImplementaci√≥n de tecnolog√≠as modernas como Motion Capture (captura de movimiento) y Simulaci√≥n de Multitudes.

<table>
  <tr>
    <td><img width="225" height="225" alt="image" src="https://github.com/user-attachments/assets/a2fb255e-424e-4a3b-8fe7-d6626c2dddd0" /></td>
    <td><img width="289" height="174" alt="image" src="https://github.com/user-attachments/assets/d3ced88a-a8f4-4f67-9e3c-aef7bd453a85" />
</td>
  </tr>
</table>

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<div align="center">
<h1> üåç 1.2 √Åreas de Aplicaci√≥n de la Graficaci√≥n </h1>

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)
<p><i>El impacto de los algoritmos visuales en la sociedad moderna y la industria</i></p>
</div>

üî¥ Sectores de Impacto Cr√≠tico
La graficaci√≥n por computadora ha dejado de ser una herramienta exclusiva de ingenieros para convertirse en la columna vertebral de m√∫ltiples industrias. Seg√∫n la documentaci√≥n, 
estas son las √°reas donde la tecnolog√≠a visual define el √©xito:

üéÆ Entretenimiento y Medios: * Desarrollo de videojuegos con renderizado en tiempo real.
Efectos visuales (VFX) en el cine utilizando t√©cnicas de Animaci√≥n 3D de Alta Complejidad.

<img width="275" height="183" alt="image" src="https://github.com/user-attachments/assets/57b3a7e3-22ae-4066-a64b-f778bb5c8df8" />


üè• Ciencia y Medicina: * Visualizaci√≥n de datos m√©dicos mediante tomograf√≠as y resonancias magn√©ticas.
Simulaci√≥n de cirug√≠as en entornos virtuales para entrenamiento m√©dico sin riesgo.

<img width="312" height="162" alt="image" src="https://github.com/user-attachments/assets/b58a6ace-9dd8-4b08-bf25-4b78ee7acbaf" />


üèóÔ∏è Dise√±o e Ingenier√≠a (CAD/CAM): * Modelado de prototipos industriales y arquitectura digital.
An√°lisis de estructuras mediante herramientas matem√°ticas para el trazo de mallas.

<img width="275" height="183" alt="image" src="https://github.com/user-attachments/assets/fdc3ffe9-36ae-4ad4-9304-5d7588913c61" />


üîµ √Åreas de Impacto Tecnol√≥gico Moderno

Simulaci√≥n de Multitudes: Uso de sistemas aut√≥nomos para recrear comportamientos humanos masivos en entornos digitales.
Arte Generativo: Empleo de algoritmos matem√°ticos para crear obras est√©ticas complejas de forma automatizada.
Interactividad Din√°mica: Animaciones 2D y 3D donde el usuario final tiene el control total sobre el entorno.

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<div align="center">
<h1> üìê 1.3 Aspectos Matem√°ticos de la Graficaci√≥n </h1>

 ![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)
<p><i>La arquitectura l√≥gica y num√©rica que sostiene la realidad virtual</i></p>
</div>

üî¥ Los Cimientos: Geometr√≠a y Aritm√©tica

Detr√°s de cada renderizado en Blender, existe una ejecuci√≥n masiva de herramientas matem√°ticas para el trazo y procesamiento de datos. En la graficaci√≥n, no movemos "objetos", 
movemos puntos en un espacio vectorial mediante:

Sistemas de Coordenadas: Definici√≥n de puntos en espacios 2D (X, Y) y 3D (X, Y, Z).
Vectores y Matrices: Estructuras fundamentales para calcular posiciones, direcciones de luz y orientaciones de c√°mara.
Funciones Trigonom√©tricas: Uso de seno y coseno para generar curvas, rotaciones y trayectorias org√°nicas.


üîµ Transformaciones Lineales: El Inicio del Movimiento
Para que un objeto cambie de lugar, tama√±o o forma, se aplica la representaci√≥n matricial. Estas son las tres transformaciones base que implementamos en nuestros scripts:


1Ô∏è‚É£Escalamiento: Alteraci√≥n del tama√±o de la malla multiplicando sus coordenadas por un factor de escala.

2Ô∏è‚É£Rotaci√≥n: Giro del objeto sobre un eje espec√≠fico utilizando √°ngulos en radianes y matrices de rotaci√≥n.

3Ô∏è‚É£Dato T√©cnico: En Blender, estas transformaciones se ven reflejadas cuando usamos comandos como location, scale y rotation_euler.

üü¢ Modelos de Iluminaci√≥n: Matem√°ticas de la Luz

La luz no es un "brillo", es un c√°lculo de c√≥mo los rayos rebotan en una superficie. El PDF destaca dos algoritmos matem√°ticos clave:

‚≠ïGouraud Shading: Calcula el color en los v√©rtices e interpola linealmente en la cara del pol√≠gono. Es r√°pido pero menos preciso.

‚≠ïPhong Shading: Calcula la iluminaci√≥n por cada p√≠xel, permitiendo reflejos especulares (brillos) mucho m√°s reales.


üíª Aplicaci√≥n en nuestras Pr√°cticas
En el c√≥digo de la Flor de la Vida y el Pol√≠gono, aplicamos estos conceptos directamente:

```Python
# Uso de trigonometr√≠a para transformar grados a coordenadas cartesianas
x = radio * math.cos(math.radians(angulo_actual))
y = radio * math.sin(math.radians(angulo_actual))
```
 ![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<div align="center">
<h1> üé® 1.4 Modelos de Color: El ADN Visual </h1>

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)
<p><i>La ciencia de la luz y la representaci√≥n crom√°tica en sistemas digitales</i></p>
</div>

üî¥ Fundamentos Crom√°ticos
En la graficaci√≥n, el color no es solo est√©tica; es una base t√©cnica para la representaci√≥n crom√°tica en computaci√≥n. Dependiendo del medio (pantalla o papel) y del objetivo 
(edici√≥n o visualizaci√≥n), utilizamos distintos modelos:

‚≠ïRGB (Red, Green, Blue): Modelo aditivo. Es el est√°ndar para monitores. La suma de los tres colores en su m√°xima intensidad produce blanco.

‚≠ïCMY (Cyan, Magenta, Yellow): Modelo sustractivo. Base de la impresi√≥n f√≠sica.

‚≠ïHSV / HSL (Hue, Saturation, Value/Lightness): Modelos basados en la percepci√≥n humana, ideales para artistas digitales porque separan el matiz de la intensidad y el brillo.

üîµ Sombreado y T√©cnicas de Iluminaci√≥n

1Ô∏è‚É£Gouraud Shading: Realiza un c√°lculo de color en los v√©rtices e interpola los valores. Es eficiente pero puede perder detalles de brillo (puntos especulares).

2Ô∏è‚É£Phong Shading: Realiza el c√°lculo por cada p√≠xel. Es el que permite ese acabado "pl√°stico" o "met√°lico" brillante que vemos en renders profesionales.

---

üí° Tutorial Pr√°ctico: Iluminaci√≥n de Caras en Blender
Para aterrizar este concepto, realizamos una pr√°ctica donde asignamos colores espec√≠ficos a las caras de un cubo. Esto nos ayuda a entender c√≥mo Blender gestiona los Material Slots.

üõ†Ô∏è Paso a Paso del Script:

1Ô∏è‚É£Definir el Material: Creamos un contenedor de material y le asignamos un color en formato RGBA.

2Ô∏è‚É£Asignar a la Malla: Vinculamos el material al objeto seleccionado.

3Ô∏è‚É£Mapeo de √çndices: Cada cara del cubo tiene un √≠ndice (0 a 5); asignamos un material distinto a cada una.

```Python
import bpy

# Crear material rojo
mat_rojo = bpy.data.materials.new(name="Rojo")
mat_rojo.diffuse_color = (1, 0, 0, 1) # RGB + Alpha

# Aplicar al objeto activo
obj = bpy.context.active_object
obj.data.materials.append(mat_rojo)

# En modo edici√≥n se pueden asignar a caras espec√≠ficas
```
üü¢ Interactividad y Control del Usuario

El modelo de color no es est√°tico. En graficaci√≥n avanzada, las animaciones 2D y 3D son controladas din√°micamente por el usuario final, permitiendo que los colores cambien 
en tiempo real seg√∫n la posici√≥n de la luz o la interacci√≥n del cursor.

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<div align="center">
<h1> üìê 1.5 Representaci√≥n y Trazo de L√≠neas y Pol√≠gonos </h1>

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)
<p><i>La geometr√≠a anal√≠tica aplicada a la creaci√≥n de mallas y estructuras 3D</i></p>
</div>

>

üî¥ Fundamentos del Trazo Digital
La representaci√≥n de formas en graficaci√≥n no es un dibujo a mano alzada; es la implementaci√≥n mediante representaci√≥n matricial y curvas complejas. El trazo se basa en 
definir puntos (v√©rtices) y las reglas que los conectan:

‚≠ïPuntos y V√©rtices: La unidad m√≠nima en el espacio 3D.

‚≠ïAristas (Edges): Conexiones lineales entre dos v√©rtices.

‚≠ïPol√≠gonos (Faces): Superficies cerradas formadas por 3 o m√°s aristas.

‚≠ïFormatos de Imagen: La distinci√≥n entre Mapas de Bits (p√≠xeles est√°ticos) y Gr√°ficos Vectoriales (f√≥rmulas matem√°ticas que no pierden calidad).

<img width="3999" height="2667" alt="image" src="https://github.com/user-attachments/assets/7738babc-dcea-4608-a5a5-1f7842e8d856" />

üîµ 1.5.1 Pr√°ctica Integradora: El Pol√≠gono Maestro
En esta pr√°ctica, aplicamos la conversi√≥n de coordenadas polares a cartesianas para generar un pol√≠gono regular de "n" lados de forma automatizada.

<details>
<summary><b>üìÇ Ver C√≥digo: Generaci√≥n de Pol√≠gono 2D</b></summary>

  ```Python
import bpy
import math

def crear_poligono_2d(nombre, lados, radio):
    malla = bpy.data.meshes.new(nombre)
    objeto = bpy.data.objects.new(nombre, malla)
    bpy.context.collection.objects.link(objeto)
    
    vertices, aristas = [], []
    
    # üìê Matem√°ticas del Trazo:
    for i in range(lados):
        angulo = 2 * math.pi * i / lados
        x = radio * math.cos(angulo) # Abscisa
        y = radio * math.sin(angulo) # Ordenada
        vertices.append((x, y, 0))
        aristas.append((i, (i + 1) % lados)) # Conexi√≥n secuencial
        
    malla.from_pydata(vertices, aristas, [])
    malla.update()

crear_poligono_2d("PoligonoG", lados=6, radio=5)
```
</details>


üü¢ 1.5.2 Pr√°ctica Avanzada: La Flor de la Vida
Este ejercicio demuestra la evoluci√≥n de m√©todos cl√°sicos para secuencias fluidas. Usamos ciclos while para repetir un trazo circular, creando una estructura de geometr√≠a sagrada 
basada en la repetici√≥n constante de 60¬∞.

‚≠ïL√≥gica de Repetici√≥n: El patr√≥n se genera rotando el centro de cada c√≠rculo alrededor de un eje central.

‚≠ïControl de Usuario: Mediante el script, podemos decidir el n√∫mero de p√©talos y el radio de forma din√°mica.

```Python
# L√≥gica de rotaci√≥n circular
while angulo_actual < 360:
    x = radio * math.cos(math.radians(angulo_actual))
    y = radio * math.sin(math.radians(angulo_actual))
    bpy.ops.mesh.primitive_circle_add(radius=radio, location=(x, y, 0))
    angulo_actual += paso_angular
```

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

<div align="center">
<h1> üñºÔ∏è 1.6 Procesamiento de Mapas de Bits </h1>

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)
<p><i>La manipulaci√≥n de p√≠xeles y el control matricial de la imagen r√°ster</i></p>
</div>

üî¥ ¬øQu√© es un Mapa de Bits (Raster)?

A diferencia de los pol√≠gonos que hemos programado (que son matem√°ticos y vectoriales), el Procesamiento de Mapas de Bits se enfoca en la manipulaci√≥n de una rejilla de puntos 
individuales llamados p√≠xeles. Cada p√≠xel contiene informaci√≥n crom√°tica basada en los modelos que vimos anteriormente (RGB).

üîµ T√©cnicas Cr√≠ticas de Procesamiento

Seg√∫n la ruta de aprendizaje de nuestra unidad, el procesamiento de mapas de bits implica varias capas de control:

1Ô∏è‚É£Filtrado Digital: Modificaci√≥n de los valores num√©ricos de los p√≠xeles mediante matrices de convoluci√≥n (ej. desenfoque, detecci√≥n de bordes, realce de color).

2Ô∏è‚É£Transformaciones de Espacio de Color: Convertir una imagen de RGB a escala de grises o a CMY para procesos de impresi√≥n, ajustando la luminancia y saturaci√≥n.

3Ô∏è‚É£Compresi√≥n y Formatos: * Lossy (Con p√©rdida): Como el JPEG, ideal para fotograf√≠as donde se sacrifica detalle por peso.

‚≠ïLossless (Sin p√©rdida): Como el PNG, esencial para texturas en Blender que requieren transparencia (Alpha Channel).


üü¢ Relaci√≥n con el Escenario 3D (Texturizado)

En nuestra pr√°ctica del Escenario Virtual, el mapa de bits juega un papel fundamental a trav√©s del Texture Mapping:

‚≠ïMapeo UV: Es el proceso de proyectar un mapa de bits (imagen 2D) sobre la superficie de una malla poligonal (3D).

‚≠ïMapas de Normales: Mapas de bits especiales que enga√±an al ojo simulando relieve y profundidad en superficies planas sin a√±adir pol√≠gonos reales.

Dato de Ingenier√≠a: Mientras que el pol√≠gono define la forma, el mapa de bits define la identidad visual (piel, metal, madera) del objeto.


üèÅ Conclusi√≥n de la Unidad 1
<div align="center">
<p align="justify">
La Unidad 1 de <b>Graficaci√≥n</b> nos ha llevado desde los fundamentos hist√≥ricos de Ivan Sutherland hasta la complejidad t√©cnica del procesamiento de p√≠xeles y pol√≠gonos. Hemos comprendido que la <b>Graficaci√≥n por Computadora</b> no es solo dibujar, es <b>programar la luz y la geometr√≠a</b> mediante algoritmos matem√°ticos controlados.
</p>

</div>


